var valtio = (function (exports, react, proxyCompare, useSubscription) {
  'use strict';

  /*
  export {
    unstable_createMutableSource as createMutableSource,
    unstable_useMutableSource as useMutableSource,
  } from 'react'
  */
  var TARGET = Symbol();
  var createMutableSource = function createMutableSource(target, _getVersion) {
    var _ref;

    return _ref = {}, _ref[TARGET] = target, _ref;
  };
  var useMutableSource = function useMutableSource(source, getSnapshot, _subscribe) {
    var subscription = react.useMemo(function () {
      return {
        getCurrentValue: function getCurrentValue() {
          return getSnapshot(source[TARGET]);
        },
        subscribe: function subscribe(callback) {
          return _subscribe(source[TARGET], callback);
        }
      };
    }, [source, getSnapshot, _subscribe]);
    return useSubscription.useSubscription(subscription);
  };

  var VERSION = Symbol();
  var LISTENERS = Symbol();
  var SNAPSHOT = Symbol();

  var isSupportedObject = function isSupportedObject(x) {
    return typeof x === 'object' && x !== null && (Array.isArray(x) || !x[Symbol.iterator]) && !(x instanceof WeakMap) && !(x instanceof WeakSet);
  }; // XXX all unsupported objects are not listed here. is there a better way?


  var proxyCache = new WeakMap();
  var globalVersion = 0;
  var snapshotCache = new WeakMap();
  var proxy = function proxy(initialObject) {
    if (initialObject === void 0) {
      initialObject = {};
    }

    if (!isSupportedObject(initialObject)) {
      throw new Error('unsupported object type');
    }

    var version = globalVersion;
    var listeners = new Set();

    var notifyUpdate = function notifyUpdate(nextVersion) {
      if (!nextVersion) {
        nextVersion = ++globalVersion;
      }

      if (version !== nextVersion) {
        version = nextVersion;
        listeners.forEach(function (listener) {
          return listener(nextVersion);
        });
      }
    };

    var emptyCopy = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
    var p = new Proxy(emptyCopy, {
      get: function get(target, prop, receiver) {
        if (prop === VERSION) {
          return version;
        }

        if (prop === LISTENERS) {
          return listeners;
        }

        if (prop === SNAPSHOT) {
          var cache = snapshotCache.get(receiver);

          if (cache && cache.version === version) {
            return cache.snapshot;
          }

          var _snapshot = Array.isArray(target) ? [] : {};

          snapshotCache.set(receiver, {
            version: version,
            snapshot: _snapshot
          });
          Reflect.ownKeys(Object.getPrototypeOf(target) || {}).forEach(function (key) {
            if (key === Symbol.unscopables) return;

            try {
              var value = target[key]; // if (typeof value === 'function') {
              //   snapshot[key] = value.bind(target)
              // } else {

              _snapshot[key] = value; // }
            } catch (e) {
              console.error(e);
            }
          });
          Reflect.ownKeys(target).forEach(function (key) {
            var value = target[key];

            if (!isSupportedObject(value)) {
              _snapshot[key] = value;
            } else if (value instanceof Promise) {
              Object.defineProperty(_snapshot, key, {
                get: function get() {
                  throw value;
                }
              });
            } else {
              _snapshot[key] = value[SNAPSHOT];
            }
          });

          if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {
            Object.freeze(_snapshot);
          }

          return _snapshot;
        }

        return target[prop];
      },
      deleteProperty: function deleteProperty(target, prop) {
        var prevValue = target[prop];
        var childListeners = isSupportedObject(prevValue) && prevValue[LISTENERS];

        if (childListeners) {
          childListeners.delete(notifyUpdate);
        }

        var deleted = Reflect.deleteProperty(target, prop);

        if (deleted) {
          notifyUpdate();
        }

        return deleted;
      },
      set: function set(target, prop, value, receiver) {
        var prevValue = target[prop];

        if (Object.is(prevValue, value)) {
          return true;
        }

        var childListeners = isSupportedObject(prevValue) && prevValue[LISTENERS];

        if (childListeners) {
          childListeners.delete(notifyUpdate);
        }

        if (!isSupportedObject(value)) {
          target[prop] = value;
        } else if (value instanceof Promise) {
          target[prop] = value.then(function (v) {
            receiver[prop] = v;
          });
        } else {
          value = proxyCompare.getUntrackedObject(value) || value;

          if (value[LISTENERS]) {
            target[prop] = value;
          } else if (proxyCache.has(value)) {
            target[prop] = proxyCache.get(value);
          } else {
            target[prop] = proxy(value);
          }

          target[prop][LISTENERS].add(notifyUpdate);
        }

        notifyUpdate();
        return true;
      }
    });
    proxyCache.set(initialObject, p);
    Reflect.ownKeys(initialObject).forEach(function (key) {
      p[key] = initialObject[key];
    });
    return p;
  };
  var subscribe = function subscribe(p, callback) {
    var pendingVersion = 0;

    var listener = function listener(nextVersion) {
      pendingVersion = nextVersion;
      Promise.resolve().then(function () {
        if (nextVersion === pendingVersion) {
          callback();
        }
      });
    };

    p[LISTENERS].add(listener);
    return function () {
      p[LISTENERS].delete(listener);
    };
  };
  var snapshot = function snapshot(p) {
    return p[SNAPSHOT];
  };

  var mutableSourceCache = new WeakMap();

  var getMutableSource = function getMutableSource(p) {
    if (!mutableSourceCache.has(p)) {
      mutableSourceCache.set(p, createMutableSource(p));
    }

    return mutableSourceCache.get(p);
  };

  var useProxy = function useProxy(p) {
    var affected = new WeakMap();
    var lastAffected = react.useRef();
    react.useEffect(function () {
      lastAffected.current = affected;
    });
    var getChangedSnapshot = react.useMemo(function () {
      var prevSnapshot = null;
      var deepChangedCache = new WeakMap();
      return function (p) {
        var nextSnapshot = snapshot(p);

        try {
          if (prevSnapshot !== null && lastAffected.current && !proxyCompare.isDeepChanged(prevSnapshot, nextSnapshot, lastAffected.current, deepChangedCache)) {
            // not changed
            return prevSnapshot;
          }
        } catch (e) {// ignore and return new nextSnapshot
        }

        return prevSnapshot = nextSnapshot;
      };
    }, []);
    var currSnapshot = useMutableSource(getMutableSource(p), getChangedSnapshot, subscribe);
    var proxyCache = react.useMemo(function () {
      return new WeakMap();
    }, []); // per-hook proxyCache

    return proxyCompare.createDeepProxy(currSnapshot, affected, proxyCache);
  };

  exports.proxy = proxy;
  exports.snapshot = snapshot;
  exports.subscribe = subscribe;
  exports.useProxy = useProxy;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

}({}, React, proxyCompare, useSubscription));
