import { useMemo, useRef, useEffect } from 'react';
import { getUntrackedObject, isDeepChanged, createDeepProxy } from 'proxy-compare';
import { useSubscription } from 'use-subscription';

/*
export {
  unstable_createMutableSource as createMutableSource,
  unstable_useMutableSource as useMutableSource,
} from 'react'
*/
const TARGET = Symbol();
const createMutableSource = (target, _getVersion) => ({
  [TARGET]: target
});
const useMutableSource = (source, getSnapshot, subscribe) => {
  const subscription = useMemo(() => ({
    getCurrentValue: () => getSnapshot(source[TARGET]),
    subscribe: callback => subscribe(source[TARGET], callback)
  }), [source, getSnapshot, subscribe]);
  return useSubscription(subscription);
};

const VERSION = Symbol();
const LISTENERS = Symbol();
const SNAPSHOT = Symbol();

const isSupportedObject = x => typeof x === 'object' && x !== null && (Array.isArray(x) || !x[Symbol.iterator]) && !(x instanceof WeakMap) && !(x instanceof WeakSet); // XXX all unsupported objects are not listed here. is there a better way?


const proxyCache = new WeakMap();
let globalVersion = 0;
const snapshotCache = new WeakMap();
const proxy = (initialObject = {}) => {
  if (!isSupportedObject(initialObject)) {
    throw new Error('unsupported object type');
  }

  let version = globalVersion;
  const listeners = new Set();

  const notifyUpdate = nextVersion => {
    if (!nextVersion) {
      nextVersion = ++globalVersion;
    }

    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach(listener => listener(nextVersion));
    }
  };

  const emptyCopy = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const p = new Proxy(emptyCopy, {
    get(target, prop, receiver) {
      if (prop === VERSION) {
        return version;
      }

      if (prop === LISTENERS) {
        return listeners;
      }

      if (prop === SNAPSHOT) {
        const cache = snapshotCache.get(receiver);

        if (cache && cache.version === version) {
          return cache.snapshot;
        }

        const snapshot = Array.isArray(target) ? [] : {};
        snapshotCache.set(receiver, {
          version,
          snapshot
        });
        Reflect.ownKeys(Object.getPrototypeOf(target) || {}).forEach(key => {
          if (key === Symbol.unscopables) return;

          try {
            const value = target[key]; // if (typeof value === 'function') {
            //   snapshot[key] = value.bind(target)
            // } else {

            snapshot[key] = value; // }
          } catch (e) {
            console.error(e);
          }
        });
        Reflect.ownKeys(target).forEach(key => {
          const value = target[key];

          if (!isSupportedObject(value)) {
            snapshot[key] = value;
          } else if (value instanceof Promise) {
            Object.defineProperty(snapshot, key, {
              get() {
                throw value;
              }

            });
          } else {
            snapshot[key] = value[SNAPSHOT];
          }
        });

        if (typeof process === 'object' && process.env.NODE_ENV !== 'production') {
          Object.freeze(snapshot);
        }

        return snapshot;
      }

      return target[prop];
    },

    deleteProperty(target, prop) {
      const prevValue = target[prop];
      const childListeners = isSupportedObject(prevValue) && prevValue[LISTENERS];

      if (childListeners) {
        childListeners.delete(notifyUpdate);
      }

      const deleted = Reflect.deleteProperty(target, prop);

      if (deleted) {
        notifyUpdate();
      }

      return deleted;
    },

    set(target, prop, value, receiver) {
      const prevValue = target[prop];

      if (Object.is(prevValue, value)) {
        return true;
      }

      const childListeners = isSupportedObject(prevValue) && prevValue[LISTENERS];

      if (childListeners) {
        childListeners.delete(notifyUpdate);
      }

      if (!isSupportedObject(value)) {
        target[prop] = value;
      } else if (value instanceof Promise) {
        target[prop] = value.then(v => {
          receiver[prop] = v;
        });
      } else {
        value = getUntrackedObject(value) || value;

        if (value[LISTENERS]) {
          target[prop] = value;
        } else if (proxyCache.has(value)) {
          target[prop] = proxyCache.get(value);
        } else {
          target[prop] = proxy(value);
        }

        target[prop][LISTENERS].add(notifyUpdate);
      }

      notifyUpdate();
      return true;
    }

  });
  proxyCache.set(initialObject, p);
  Reflect.ownKeys(initialObject).forEach(key => {
    p[key] = initialObject[key];
  });
  return p;
};
const subscribe = (p, callback) => {
  let pendingVersion = 0;

  const listener = nextVersion => {
    pendingVersion = nextVersion;
    Promise.resolve().then(() => {
      if (nextVersion === pendingVersion) {
        callback();
      }
    });
  };

  p[LISTENERS].add(listener);
  return () => {
    p[LISTENERS].delete(listener);
  };
};
const snapshot = p => p[SNAPSHOT];

const mutableSourceCache = new WeakMap();

const getMutableSource = p => {
  if (!mutableSourceCache.has(p)) {
    mutableSourceCache.set(p, createMutableSource(p));
  }

  return mutableSourceCache.get(p);
};

const useProxy = p => {
  const affected = new WeakMap();
  const lastAffected = useRef();
  useEffect(() => {
    lastAffected.current = affected;
  });
  const getChangedSnapshot = useMemo(() => {
    let prevSnapshot = null;
    const deepChangedCache = new WeakMap();
    return p => {
      const nextSnapshot = snapshot(p);

      try {
        if (prevSnapshot !== null && lastAffected.current && !isDeepChanged(prevSnapshot, nextSnapshot, lastAffected.current, deepChangedCache)) {
          // not changed
          return prevSnapshot;
        }
      } catch (e) {// ignore and return new nextSnapshot
      }

      return prevSnapshot = nextSnapshot;
    };
  }, []);
  const currSnapshot = useMutableSource(getMutableSource(p), getChangedSnapshot, subscribe);
  const proxyCache = useMemo(() => new WeakMap(), []); // per-hook proxyCache

  return createDeepProxy(currSnapshot, affected, proxyCache);
};

export { proxy, snapshot, subscribe, useProxy };
