/*auto-generated by: https://github.com/pmndrs/gltfjsx*/import React, {useRef, useState, useEffect} from 'react'import {useFrame} from 'react-three-fiber'import {useGLTF} from '@react-three/drei/useGLTF'import {GLTF} from 'three/examples/jsm/loaders/GLTFLoader'import {    AnimationAction,    AnimationMixer,    Bone, Group,    LoopOnce,    MeshStandardMaterial,    MeshToonMaterial,    SkinnedMesh} from "three";import {hexStringToCode} from "../../../utils/color";import {SkeletonUtils} from "three/examples/jsm/utils/SkeletonUtils";import {setMaterials, setShadows} from "../../../utils/models";import {Event} from "three/src/core/EventDispatcher";type GLTFResult = GLTF & {    nodes: {        Demon001: SkinnedMesh        Body: Bone        Head: Bone    }    materials: {        Texture: MeshStandardMaterial    }}type ActionName =    | 'Bite_Front'    | 'Bite_InPlace'    | 'Dance'    | 'Death'    | 'HitRecieve'    | 'Idle'    | 'Jump'    | 'No'    | 'Walk'    | 'Yes'type GLTFActions = Record<ActionName, AnimationAction>const lightOrangeIndividualMaterial = new MeshToonMaterial({    color: hexStringToCode("#630721"),    skinning: true,});lightOrangeIndividualMaterial.color.convertSRGBToLinear();export default function Demon({isDead, lastHit, ...props}: JSX.IntrinsicElements['group'] & {    isDead: boolean,    lastHit: number,}) {    const group = useRef<Group>()    const {nodes, materials, animations, scene} = useGLTF('/Demon.glb') as GLTFResult    const [geometry]: any = useState(() => {        const clonedScene = SkeletonUtils.clone(scene)        setMaterials(clonedScene, {            Texture: lightOrangeIndividualMaterial        })        setShadows(clonedScene)        return clonedScene    })    const currentAnimationRef = useRef<{        key: string | null,        animation: any,        finished: boolean,    }>({        key: null,        animation: null,        finished: false,    })    const actions = useRef<GLTFActions>()    const [mixer] = useState(() => new AnimationMixer(nodes.Demon001))    useFrame((state, delta) => mixer.update(delta))    useEffect(() => {        actions.current = {            Bite_Front: mixer.clipAction(animations[0], group.current),            Bite_InPlace: mixer.clipAction(animations[1], group.current),            Dance: mixer.clipAction(animations[2], group.current),            Death: mixer.clipAction(animations[3], group.current),            HitRecieve: mixer.clipAction(animations[4], group.current),            Idle: mixer.clipAction(animations[5], group.current),            Jump: mixer.clipAction(animations[6], group.current),            No: mixer.clipAction(animations[7], group.current),            Walk: mixer.clipAction(animations[8], group.current),            Yes: mixer.clipAction(animations[9], group.current),        }        actions.current.Death.loop = LoopOnce        actions.current.Death.clampWhenFinished = true        actions.current.HitRecieve.loop = LoopOnce        actions.current.HitRecieve.clampWhenFinished = true        return () => animations.forEach((clip) => mixer.uncacheClip(clip))    }, [])    useEffect(() => {        let unsubscribe = () => {}        const calculateAnimation = () => {            if (!actions.current) return            const currentAnimation = currentAnimationRef.current            const duration = 0.2            const fadeOutCurrent = (fadeDuration = duration) => {                if (currentAnimation.animation) {                    currentAnimation.animation.fadeOut(fadeDuration)                }            }            const isHit = lastHit > Date.now() - 100            const key = lastHit.toString()            if (isDead) {                if (currentAnimation.animation) {                    fadeOutCurrent()                    actions.current.Death                        .reset()                        .setEffectiveWeight(1)                        .fadeIn(duration)                        .play();                    currentAnimation.animation = actions.current.Death                    currentAnimation.key = null                    currentAnimation.finished = false                } else {                    actions.current.Death                        .reset()                        .setEffectiveWeight(1)                        .play();                    currentAnimation.animation = actions.current.Death                    currentAnimation.key = null                    currentAnimation.finished = false                }            } else if (isHit || (currentAnimation.key === key && !currentAnimation.finished)) {                if (currentAnimation.animation && currentAnimation.key === key) {                    //                } else {                    if (currentAnimation.animation) {                        fadeOutCurrent(0.1)                        actions.current.HitRecieve                            .reset()                            .setEffectiveWeight(1)                            .fadeIn(duration)                            .play();                        currentAnimation.animation = actions.current.HitRecieve                        currentAnimation.key = key                        currentAnimation.finished = false                    } else {                        actions.current.HitRecieve                            .reset()                            .setEffectiveWeight(1)                            .play();                        currentAnimation.animation = actions.current.HitRecieve                        currentAnimation.key = key                        currentAnimation.finished = false                    }                }                const onFinished = (event: Event) => {                    mixer.removeEventListener('finished', onFinished)                    if (actions.current && event.action === actions.current.HitRecieve) {                        currentAnimation.finished = true                        calculateAnimation()                    }                }                mixer.addEventListener('finished', onFinished)                unsubscribe = () => {                    mixer.removeEventListener('finished', onFinished)                }            } else {                if (currentAnimation.animation) {                    fadeOutCurrent()                    actions.current.Dance                        .reset()                        .setEffectiveWeight(1)                        .fadeIn(duration)                        .play();                    currentAnimation.animation = actions.current.Dance                    currentAnimation.key = null                    currentAnimation.finished = false                } else {                    actions.current.Dance                        .reset()                        .setEffectiveWeight(1)                        .play();                    currentAnimation.animation = actions.current.Dance                    currentAnimation.key = null                    currentAnimation.finished = false                }            }        }        calculateAnimation()        return () => {            unsubscribe()        }    }, [isDead, lastHit])    return (        <group ref={group} {...props} dispose={null}>            <primitive object={geometry} dispose={null} />        </group>    )}useGLTF.preload('/Demon.glb')